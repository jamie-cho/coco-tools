procedure ecb_at
    param location: real
    run ecb_locate(float(land(location, 31)), location / 32.0)


procedure ecb_button
    param button: real
    param retval: real
    dim joystk, fire, x, y: integer

    if button < 2 then \ joystk = 0 \ else \ joystk = 1 \ endif
    run GFX("Joystk", button, fire, x, y)
    if land(button, 1) = 0 then \ retval = land(fire, 1) \ endif
    if land(button, 1) = 1 then \ retval = land(fire, 2) / 2  \ endif


procedure ecb_joystk
    param joystk, joy0x, joy0y, joy1x, joy1y, retval: real
    dim fire: integer

    if joystk = 0 then
        run GFX("Joystk", 0, fire, joy0x, joy0y)
        run GFX("Joystk", 1, fire, joy1x, joy1y)
    endif

    if joystk = 0 then retval = joy0x \ endif
    if joystk = 1 then retval = joy0y \ endif
    if joystk = 2 then retval = joy1x \ endif
    if joystk = 3 then retval = joy1y \ endif


procedure ecb_cls
    param color: real
    dim a, b, ii: integer
    dim c: byte
    if color = 1 or color > 8 then
        c = $0c
        put #1, c
        if color > 8 then
            print("MICROSOFT")
        endif
    else
        c = $01
        put #1,c
        run _ecb_text_address(a)
        if a <> -1 then
            b = a + 511
            if color = 0 then
                c = 128
            else
                c = 143 + land(7, color - 1) * 16
            endif
            for ii = a to b
                poke ii,c
            next ii
        endif
    endif


procedure ecb_hex
    param v: real
    param str: string
    dim ival: integer
    dim tmp: string

    if v < 0 or v >= 65536 then
        error 52
    endif

    ival = v
    run _ecb_hex_digit(land($f, v / $1000), str)
    run _ecb_hex_digit(land($f, v / $100), tmp)
    str = str + tmp
    run _ecb_hex_digit(land($f, v / $10), tmp)
    str = str + tmp
    run _ecb_hex_digit(land($f, v), tmp)
    str = str + tmp


procedure ecb_instr
    param index: real
    param str0: string
    param str1: string
    param outindex: real
    dim ii: integer

    for ii = index to len(str0) - len(str1)
        if str1 = mid$(str0, ii, ii + len(str1)) then
            outindex = ii
        endif
    next ii


procedure ecb_int
    param v, retval: real
    if v >= 0 then
        retval = int(v)
    else
        retval = int(v - 0.999999999)
    endif


procedure ecb_locate
    param x, y: real

    dim tmp_buffer(3): byte
    tmp_buffer(1) = $02
    tmp_buffer(2) = $20 + x
    tmp_buffer(3) = $20 + y
    put #1, tmp_buffer


procedure ecb_point
    param x, y, c0: real
    dim address, c, cc: integer
    run _ecb_get_point_info(x, y, address, c, cc)
    if address = -1 then
        error 52
    endif
    if cc > $80 then
        if land(c, cc) <> 0 then
            c0 = 1 + land($7f, cc) / 16
        else
            c0 = 0
        endif
    else
        c0 = -1
    endif


procedure ecb_read_filter
    param inval: string
    param outval: real
    if inval = "" then
        outval = 0.0
    else
        outval = val(inval)
    endif


procedure ecb_reset
    param x, y: real
    dim address, c0, c1: integer
    run _ecb_get_point_info(x, y, address, c1, c0)
    if address = -1 then
        error 52
    endif
    if c0 < $80 then
        c0 = $80
    else
        c0 = land(c0, $8f)
    endif
    poke address, land(c0, $ff - c1)


procedure ecb_set
    param x, y, c: real
    dim address, c0, c1: integer
    if c < 0 or c > 8 then
        error 52
    endif
    if c = 0 then
        c = 1
    endif
    run _ecb_get_point_info(x, y, address, c1, c0)
    if address = -1 then
        error 52
    endif
    if c0 < $80 then
        c0 = $80
    else
        c0 = land(c0, $8f)
    endif
    poke address, lor(c0, (c - 1) * 16 + c1)


procedure ecb_sound
    param f, d, v:real
    dim fint, dint, vint:integer
    if f < 0 or f > 255 or d < 0 or d > 255 or v < 0 or v > 63 then
        error 52
    endif

    fint = int(2.49696345 * f + 3456.878733)
    dint = int(d * 4)
    vint = fix(v)
    while (dint > 255) do
        run gfx2("tone", fint, 255, vint)
        dint = dint - 255
    endwhile
    run gfx2("tone", fint, dint, vint)


procedure ecb_str
    param valin: real
    param valout: string
    valout = str$(valin)
    if mid$(valout, len(valout), 1) = "." then
        valout = " " + left$(valout, len(valout) - 1) + " "
    else
        if valout = ".0" then
            valout = " 0 "
        else
            valout = " " + valout + " "
        endif
    endif


procedure ecb_string
    param count: real
    param str: string
    param strout: string
    dim ii: integer

    if count < 0 or len(str) = 0 then
        error 52
    endif

    strout = ""
    for ii=1 to count
        strout = strout + mid$(str, 1, 1)
    next ii


procedure _ecb_text_address
    param address: integer
    type rregisters = cc, a, b, dp:byte; x, y, u:integer
    dim rregs: rregisters
    dim reqid: byte

    (* getstat ss.alfas *)
    rregs.a = 1
    rregs.b = $1c
    reqid = $8d
    run syscall(reqid, rregs)
    if land(rregs.cc, 1) <> 0 then
        address = -1
    else
        address = rregs.x
    endif


procedure _ecb_hex_digit
    param v: real
    param s: string
    if v < 10 then
        s = chr$(v + asc("0"))
    else
        s = chr$(v + asc("A"))
    endif


procedure _ecb_get_point_info
    param x, y: real
    param address, mask, c0: integer
    if x < 0 or x > 63 or y < 0 or y > 31 then
        error 52
    endif
    run _ecb_text_address(address)
    if address = -1 then
        error 52
    endif
    address = address + (y / 2) * 32 + (x / 2)
    mask = 2 ** ((2 * (1 - land(y, 1))) + (1 - land(x, 1)))
    c0 = peek(fix(address))


procedure _ecb_cursor_color
    param v: integer
    dim tmp_buffer(2): byte
    tmp_buffer(1) = $05
    tmp_buffer(2) = v + $20
    put #1, tmp_buffer


procedure _ecb_start
    run _ecb_cursor_color(0)
    SHELL("tmode pau=0")


procedure _ecb_input_prefix
    run _ecb_cursor_color(1)
    SHELL("tmode eko=1")


procedure _ecb_input_suffix
    run _ecb_cursor_color(0)
    SHELL("tmode eko=0")


procedure dup
    param inpath, outpath: integer
    type rregisters = cc, a, b, dp:byte; x, y, u:integer
    dim rregs: rregisters
    dim reqid: byte

    rregs.a = inpath
    reqid = $82
    run syscall(reqid, rregs)
    if land(rregs.cc, 1) <> 0 then
        error rregs.b
    else
        outpath = rregs.a
    endif


procedure devnm
    param inpath: integer
    param name: string
    type rregisters = cc, a, b, dp:byte; x, y, u:integer
    dim rregs: rregisters
    dim reqid: byte
    dim ii, xx: integer

    (* getstat SS.DevNm *)
    rregs.a = inpath
    rregs.b = $e
    rregs.x = addr(name)
    reqid = $8d
    run syscall(reqid, rregs)
    if land(rregs.cc, 1) <> 0 then
        error rregs.b
    else
        xx = addr(name)
        for ii=0 to 31
            if peek(xx + ii) >= 128 then
                poke xx + ii, land(peek(xx + ii), 127)
                name = left$(name, ii + 1)
                ii = 32
            endif
        next ii
    endif


procedure closeall
    close #0
    close #1
    close #2


procedure printit
    dim pathname: string
    run devnm(0, pathname)
    print pathname


procedure width
    param width: real
    dim path(3), path0, ii: integer
    dim buffer(2): byte
    dim pathname: string

    (* Get the path to the next free descriptor *)
    open #path(1), "/w":read
    run devnm(path(1), pathname)
    close #path(1)
    pathname = "/" + pathname

    (* Make sure it is the right type *)
    shell("iniz " + pathname)
    if width = 32 then
        shell("xmode " + pathname + " par=1")
    else
        shell("xmode " + pathname + " par=80")
    endif

    (* Open it for real *)
    open #path(1), pathname:read
    open #path(2), pathname:write
    open #path(3), pathname:write

    (* Replace stdin, stdout and stderr *)
    run closeall
    for ii=1 to 3
        run dup(path(ii), path0)
        if (path0 <> ii - 1) then
            error 52
        endif
    next ii

    (* Display window *)
    buffer(1) = $1b
    buffer(2) = $21
    put #1, buffer

    (* Close old paths *)
    for ii=1 to 3
        close #path(ii)
    next ii


procedure doit
    run width(32)
    input a$
    run width(80)
    input a$
